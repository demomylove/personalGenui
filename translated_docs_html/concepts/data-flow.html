<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Flow - A2UI 文档</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: 0 auto; color: #24292e; }
        h1, h2, h3 { color: #24292e; margin-top: 24px; margin-bottom: 16px; }
        h1 { border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        code { background-color: #f6f8fa; padding: 0.2em 0.4em; border-radius: 3px; font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace; font-size: 85%; }
        pre { background-color: #f6f8fa; padding: 16px; border-radius: 6px; overflow-x: auto; line-height: 1.45; }
        pre code { background-color: transparent; padding: 0; font-size: 100%; }
        a { color: #0366d6; text-decoration: none; }
        a:hover { text-decoration: underline; }
        ul { padding-left: 2em; }
        li { margin-top: 0.25em; }
        img { max-width: 100%; }
    </style>
</head>
<body>

<h1>数据流 (Data Flow)</h1>

<p>消息如何从代理流向 UI。</p>

<h2>架构</h2>

<pre><code>Agent (LLM) → A2UI Generator → Transport (SSE/WS/A2A)
                                      ↓
Client (Stream Reader) → Message Parser → Renderer → Native UI
</code></pre>

<p><img src="../assets/end-to-end-data-flow.png" alt="end-to-end-data-flow"></p>

<h2>消息格式</h2>

<p>A2UI 定义了一系列描述 UI 的 JSON 消息。流式传输时，这些消息通常格式化为 <strong>JSON Lines (JSONL)</strong>，其中每一行都是一个完整的 JSON 对象。</p>

<pre><code class="language-jsonl">{"surfaceUpdate":{"surfaceId":"main","components":[...]}}
{"dataModelUpdate":{"surfaceId":"main","contents":[{"key":"user","valueMap":[{"key":"name","valueString":"Alice"}]}]}}
{"beginRendering":{"surfaceId":"main","root":"root-component"}}
</code></pre>

<p><strong>为什么使用这种格式？</strong> 一系列独立的 JSON 对象对流式传输友好，容易被 LLM 增量生成，并且对错误具有弹性。</p>

<h2>生命周期示例：餐厅预订</h2>

<p><strong>用户：</strong> "Book a table for 2 tomorrow at 7pm"</p>

<p><strong>1. 代理定义 UI 结构：</strong></p>

<pre><code class="language-json">{"surfaceUpdate": {"surfaceId": "booking", "components": [
  {"id": "root", "component": {"Column": {"children": {"explicitList": ["header", "guests-field", "submit-btn"]}}}},
  {"id": "header", "component": {"Text": {"text": {"literalString": "Confirm Reservation"}, "usageHint": "h1"}}},
  {"id": "guests-field", "component": {"TextField": {"label": {"literalString": "Guests"}, "text": {"path": "/reservation/guests"}}}},
  {"id": "submit-btn", "component": {"Button": {"child": "submit-text", "action": {"name": "confirm", "context": [{"key": "details", "value": {"path": "/reservation"}}]}}}}
]}}
</code></pre>

<p><strong>2. 代理填充数据：</strong></p>

<pre><code class="language-json">{"dataModelUpdate": {"surfaceId": "booking", "path": "/reservation", "contents": [
  {"key": "datetime", "valueString": "2025-12-16T19:00:00Z"},
  {"key": "guests", "valueString": "2"}
]}}
</code></pre>

<p><strong>3. 代理发出渲染信号：</strong></p>

<pre><code class="language-json">{"beginRendering": {"surfaceId": "booking", "root": "root"}}
</code></pre>

<p><strong>4. 用户编辑客人数量为 "3"</strong> → 客户端自动更新 <code>/reservation/guests</code>（尚无消息发送给代理）</p>

<p><strong>5. 用户点击 "Confirm"</strong> → 客户端发送带有更新后数据的操作：</p>

<pre><code class="language-json">{"userAction": {"name": "confirm", "surfaceId": "booking", "context": {"details": {"datetime": "2025-12-16T19:00:00Z", "guests": "3"}}}}
</code></pre>

<p><strong>6. 代理响应</strong> → 更新 UI 或发送 <code>{"deleteSurface": {"surfaceId": "booking"}}</code> 以清理</p>

<h2>传输选项</h2>

<ul>
<li><strong>A2A Protocol</strong>: 多代理系统，也可用于代理到 UI 的通信</li>
<li><strong>AG UI</strong>: 双向，实时</li>
<li>... 其他</li>
</ul>

<p>详见 <a href="../transports.html">传输</a>。</p>

<h2>渐进式渲染</h2>

<p>无需等待生成完整的响应再向用户显示任何内容，响应的块可以在生成时流式传输到客户端并逐步渲染。</p>

<p>用户可以实时看到 UI 构建，而不是盯着旋转的加载图标。</p>

<h2>错误处理</h2>

<p><strong>格式错误的消息：</strong> 跳过并继续，或向代理发送错误以进行更正<br>
<strong>网络中断：</strong> 显示错误状态，重新连接，代理重新发送或恢复</p>

<h2>性能</h2>

<p><strong>批处理 (Batching)：</strong> 缓冲更新 16ms，批量渲染<br>
<strong>Diffing：</strong> 比较旧/新组件，仅更新更改的属性<br>
<strong>细粒度更新：</strong> 更新 <code>/user/name</code> 而不是整个 <code>/</code> 模型</p>

</body>
</html>
