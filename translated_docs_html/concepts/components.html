<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Components & Structure - A2UI 文档</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: 0 auto; color: #24292e; }
        h1, h2, h3 { color: #24292e; margin-top: 24px; margin-bottom: 16px; }
        h1 { border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        code { background-color: #f6f8fa; padding: 0.2em 0.4em; border-radius: 3px; font-family: SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace; font-size: 85%; }
        pre { background-color: #f6f8fa; padding: 16px; border-radius: 6px; overflow-x: auto; line-height: 1.45; }
        pre code { background-color: transparent; padding: 0; font-size: 100%; }
        a { color: #0366d6; text-decoration: none; }
        a:hover { text-decoration: underline; }
        ul { padding-left: 2em; }
        li { margin-top: 0.25em; }
    </style>
</head>
<body>

<h1>组件与结构 (Components & Structure)</h1>

<p>A2UI 对组件层级使用 <strong>邻接表模型 (adjacency list model)</strong>。这并非嵌套的 JSON 树，组件是一个带有 ID 引用的扁平列表。</p>

<h2>为什么要用扁平列表？</h2>

<p><strong>传统的嵌套方式：</strong></p>
<ul>
<li>LLM 必须一次性生成完美的嵌套结构</li>
<li>难以更新深层嵌套的组件</li>
<li>难以进行增量流式传输</li>
</ul>

<p><strong>A2UI 邻接表：</strong></p>
<ul>
<li>✅ 扁平结构，易于 LLM 生成</li>
<li>✅ 增量发送组件</li>
<li>✅ 通过 ID 更新任意组件</li>
<li>✅ 结构与数据的清晰分离</li>
</ul>

<h2>邻接表模型</h2>

<pre><code class="language-json">{
  "surfaceUpdate": {
    "components": [
      {"id": "root", "component": {"Column": {"children": {"explicitList": ["greeting", "buttons"]}}}},
      {"id": "greeting", "component": {"Text": {"text": {"literalString": "Hello"}}}},
      {"id": "buttons", "component": {"Row": {"children": {"explicitList": ["cancel-btn", "ok-btn"]}}}},
      {"id": "cancel-btn", "component": {"Button": {"child": "cancel-text", "action": {"name": "cancel"}}}},
      {"id": "cancel-text", "component": {"Text": {"text": {"literalString": "Cancel"}}}},
      {"id": "ok-btn", "component": {"Button": {"child": "ok-text", "action": {"name": "ok"}}}},
      {"id": "ok-text", "component": {"Text": {"text": {"literalString": "OK"}}}}
    ]
  }
}
</code></pre>

<p>组件通过 ID 引用子组件，而不是通过嵌套。</p>

<h2>组件基础</h2>

<p>每个组件都有：</p>

<ol>
<li><strong>ID</strong>: 唯一标识符 (<code>"welcome-message"</code>)</li>
<li><strong>Type</strong>: 组件类型 (<code>Text</code>, <code>Button</code>, <code>Card</code>)</li>
<li><strong>Properties</strong>: 该类型的特定配置</li>
</ol>

<pre><code class="language-json">{"id": "welcome", "component": {"Text": {"text": {"literalString": "Hello"}, "usageHint": "h1"}}}
</code></pre>

<h2>标准目录 (The Standard Catalog)</h2>

<p>A2UI 定义了一个按用途组织的标准组件目录：</p>

<ul>
<li><strong>Layout (布局)</strong>: Row, Column, List - 排列其他组件</li>
<li><strong>Display (显示)</strong>: Text, Image, Icon, Video, Divider - 显示信息</li>
<li><strong>Interactive (交互)</strong>: Button, TextField, CheckBox, DateTimeInput, Slider - 用户输入</li>
<li><strong>Container (容器)</strong>: Card, Tabs, Modal - 分组和组织内容</li>
</ul>

<p>有关带有示例的完整组件库，请参阅 <a href="../reference/components.html">组件参考</a>。</p>

<h2>静态 vs. 动态子组件</h2>

<p><strong>静态 (<code>explicitList</code>)</strong> - 固定的子组件 ID 列表：</p>
<pre><code class="language-json">{"children": {"explicitList": ["back-btn", "title", "menu-btn"]}}
</code></pre>

<p><strong>动态 (<code>template</code>)</strong> - 从数据生成子组件：</p>
<pre><code class="language-json">{"children": {"template": {"dataBinding": "/items", "componentId": "item-template"}}}
</code></pre>

<p>对于 <code>/items</code> 中的每一项，渲染 <code>item-template</code>。详见 <a href="data-binding.html">数据绑定</a>。</p>

<h2>注入值 (Hydrating with Values)</h2>

<p>组件通过两种方式获取值：</p>

<p><strong>Literal (字面量)</strong> - 固定值： <code>{"text": {"literalString": "Welcome"}}</code><br>
<strong>Data-bound (数据绑定)</strong> - 来自数据模型： <code>{"text": {"path": "/user/name"}}</code></p>

<p>LLM 可以生成带有字面量值的组件，或将它们绑定到数据路径以获取动态内容。</p>

<h2>组合 Surfaces</h2>

<p>组件组合成 <strong>surfaces</strong>（小部件）：</p>

<ol>
<li>LLM 通过 <code>surfaceUpdate</code> 生成组件定义</li>
<li>LLM 通过 <code>dataModelUpdate</code> 填充数据</li>
<li>LLM 通过 <code>beginRendering</code> 发出渲染信号</li>
<li>客户端作为原生小部件渲染所有组件</li>
</ol>

<p>一个 surface 是一个完整、有凝聚力的 UI（表单、仪表板、聊天等）。</p>

<h2>增量更新</h2>

<p><strong>Add (添加)</strong> - 发送包含新组件 ID 的新 <code>surfaceUpdate</code><br>
<strong>Update (更新)</strong> - 发送包含现有 ID 和新属性的 <code>surfaceUpdate</code><br>
<strong>Remove (移除)</strong> - 更新父组件的 <code>children</code> 列表以排除已移除的 ID</p>

<p>扁平结构使得所有更新都是简单的基于 ID 的操作。</p>

<h2>自定义组件</h2>

<p>除了标准目录外，客户端还可以为特定领域的需求定义自定义组件：</p>

<ul>
<li><strong>How</strong>: 在您的渲染器中注册自定义组件类型</li>
<li><strong>What</strong>: 图表、地图、自定义可视化、专用小部件</li>
<li><strong>Security</strong>: 自定义组件仍然是客户端受信任目录的一部分</li>
</ul>

<p>自定义组件从客户端的渲染器 <em>发布 (advertised)</em> 给 LLM。然后 LLM 可以在标准目录之外使用它们。</p>

<p>详见 <a href="../guides/custom-components.html">自定义组件指南</a>。</p>

<h2>最佳实践</h2>

<ol>
<li><strong>描述性 ID</strong>: 使用 <code>"user-profile-card"</code> 而不是 <code>"c1"</code></li>
<li><strong>浅层级</strong>: 避免深层嵌套</li>
<li><strong>结构与内容分离</strong>: 使用数据绑定，而非字面量</li>
<li><strong>使用模板复用</strong>: 一个模板，通过动态子组件生成多个实例</li>
</ol>

</body>
</html>
