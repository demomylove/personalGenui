<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A2UI 协议深度解析与 React Native 最佳实践</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; padding: 40px; max-width: 960px; margin: 0 auto; color: #333; background-color: #fff; }
        h1 { border-bottom: 2px solid #eaeaea; padding-bottom: 15px; color: #1a1a1a; margin-bottom: 30px; }
        h2 { border-left: 5px solid #007AFF; padding-left: 10px; margin-top: 50px; color: #2c3e50; background: #f8f9fa; padding-top: 5px; padding-bottom: 5px; }
        h3 { color: #555; margin-top: 30px; font-weight: 600; border-bottom: 1px dotted #ccc; padding-bottom: 5px; }
        code { background-color: #f6f8fa; padding: 2px 4px; border-radius: 4px; font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size: 0.9em; color: #d63384; }
        pre { background-color: #f6f8fa; padding: 16px; border-radius: 6px; overflow-x: auto; border: 1px solid #e1e4e8; }
        .mermaid { margin: 30px 0; text-align: center; }
        .note { background-color: #e6f7ff; border: 1px solid #91d5ff; padding: 15px; border-radius: 4px; margin: 20px 0; font-size: 0.95em; }
        .deep-dive { background-color: #f0f5ff; border: 1px solid #adc6ff; padding: 15px; border-radius: 4px; margin: 20px 0; }
        .comparison-table { width: 100%; border-collapse: collapse; margin-top: 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .comparison-table th, .comparison-table td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        .comparison-table th { background-color: #f2f2f2; font-weight: bold; color: #333; }
        .comparison-table tr:nth-child(even) { background-color: #fbfbfb; }
        .pros { color: green; font-weight: 600; }
        .cons { color: #d93025; font-weight: 600; }
        ul { padding-left: 20px; }
        li { margin-bottom: 8px; }
    </style>
</head>
<body>

    <h1>A2UI 协议深度解析与 React Native 最佳实践</h1>
    
    <div class="note">
        <strong>更新摘要：</strong> 本文档新增了关于 <strong>Signals (信号)</strong> 技术的深度解析、A2UI 官方 <strong>Sample 案例架构分析</strong>，以及在 React Native 中实现 <strong>“动态生长” (Dynamic Growth)</strong> 的具体技术方案。
    </div>

    <h2>1. 核心技术深挖：Signals (信号)</h2>
    
    <p>Signals 是 A2UI 实现极致流式渲染的幕后英雄。它是一种比 React State 更先进的细粒度状态管理理念（类似 Vue 的响应式系统，但更独立）。</p>

    <h3>1.1 什么是 Signals？</h3>
    <p>想象一个巨大的 Excel 表格：</p>
    <ul>
        <li><strong>React State</strong>: 修改了 A1 单元格，React 会说：“整个表格可能都变了，我要把所有单元格重新算一遍。”（虽然有 Diff，但检查过程是全量的）。</li>
        <li><strong>Signals</strong>: 修改了 A1 单元格。A1 会直接给引用了它的 C1 发信号：“老兄，我变了，你更新一下。” 表格里无关的 B2、D5 完全不知情。</li>
    </ul>

    <h3>1.2 A2UI 中的 Signals</h3>
    <p>在 A2UI 的客户端代码 (<code>signal-model-processor.ts</code>) 中：</p>
    <ul>
        <li>所有组件都存储在一个 <code>SignalMap</code> 中。</li>
        <li>当 socket 收到一个新的组件片段（如 <code>Button</code>）时，它只是往 Map 里 <code>set</code> 了一下。</li>
        <li><strong>响应链条</strong>:
            <ol>
                <li>Map 发出信号。</li>
                <li><strong>只有</strong>该 Button 的父容器（比如 Card）因为订阅了 <code>children</code> 列表，会收到信号。</li>
                <li>父容器 Card 只更新自己的 DOM 结构，插入这个新 Button。</li>
                <li>其他的 Title、Image 等兄弟节点，完全不参与由于这次插入引起的重绘计算。</li>
            </ol>
        </li>
    </ul>

    <h2>2. 官方样板间：Samples 架构解析</h2>

    <p>我们深入分析了官方示例 <code>restaurant_finder</code> (餐厅搜索)，揭示了其端到端的架构。</p>

    <h3>2.1 服务端架构 (Python ADK)</h3>
    <div class="mermaid">
    flowchart TD
        UserQuery --> Executor["agent_executor.py<br>(入口路由)"]
        Executor -->|Check Extension| Branch{Use UI?}
        Branch -- Yes --> UIAgent["agent.py"]
        Branch -- No --> TextAgent
        
        subgraph Generation["生成与校验 (伪流式)"]
            UIAgent -->|Inject Schema| LLM
            LLM -->|Generate Full JSON| Validation["校验 JSON Schema"]
            Validation -->|Split & Wrap| A2A["a2ui_extension.py"]
        end
        
        A2A -->|Streaming Output| Client
    </div>
    <p><strong>关键发现</strong>: 官方 Sample 目前采用的是 <strong>“Generate -> Validate -> Send”</strong> 模式。即等 LLM 生成完整内容并校验通过后，再一次性发给客户端。这保证了演示效果的稳定性，但牺牲了部分的流式速度。</p>

    <h3>2.2 客户端架构 (Angular/Lit)</h3>
    <p>客户端使用了 <code>a2ui-github/renderers</code> 库。核心是一个通用渲染器，它不关心业务逻辑（是找餐厅还是订机票），只关心：收到的 JSON 是什么组件？然后去 <code>Standard Catalog</code> 里找对应的实现画出来。</p>

    <h2>3. 终极问题：UI 是如何“生长”的？(Dynamic Growth)</h2>

    <p><strong>“生长” VS “重绘”</strong></p>
    <ul>
        <li><strong>当前工程 (重绘)</strong>: 每次更新，都是给一张“新图纸”。工人（React）把旧房子推倒（或者仔细比对新旧图纸），然后修补成新的样子。</li>
        <li><strong>A2UI (生长)</strong>: 给的是“指令”。指令说：“在客厅加把椅子”。工人直接搬把椅子放进去，不碰别的东西。</li>
    </ul>

    <h2>4. 实战指南：如何在 React Native 中实现“动态生长”？</h2>

    <p>要在 React Native (RN) 中实现类似 A2UI 的生长效果，我们需要抛弃“巨型 State 树”的写法，采用 <strong>归一化存储 (Normalized Store) + 原子化组件</strong>。</p>

    <h3>Step 1: 改造数据结构 (Client Store)</h3>
    <p><strong>不要</strong>存这种嵌套树：</p>
    <pre><code>// ❌ 错误示范：每次改个叶子节点，根节点引用都变了
const state = { type: "Column", children: [{ type: "Text", text: "Hi" }] };</code></pre>

    <p><strong>要</strong>改成这种数据库表结构：</p>
    <pre><code class="language-javascript">// ✅ 正确示范：Normalized Store
const store = {
    "root": { id: "root", type: "Column", childIds: ["msg1", "msg2"] },
    "msg1": { id: "msg1", type: "Text", text: "Hello" },
    "msg2": { id: "msg2", type: "Image", url: "..." }
};</code></pre>

    <h3>Step 2: 原子化组件 (Atomic Components)</h3>
    <p>组件只接受 <code>id</code> 作为 props，自己去 connect 数据。使用 <code>React.memo</code> 保证父组件刷新时，不相干的子组件不刷新。</p>

    <pre><code class="language-tsx">// 渲染器入口
const GenUIRenderer = ({ id }) => {
    // 1. 只订阅属于我这个 ID 的数据！
    // 只有当 store[id] 发生变化时，这个组件才会重绘
    const componentData = useStore(state => state[id]);

    if (!componentData) return null;

    // 2. 也是只传递 ID 给子组件
    if (componentData.type === 'Column') {
        return (
            &lt;View&gt;
                {componentData.childIds.map(childId => (
                    // 关键：这里 key 用 ID。React 看到 list 变长了，只会 append 新的 item
                    // 旧的 item 因为 props (id) 没变，会被下面 memo 拦截，直接复用！
                    &lt;MemoizedGenUIRenderer key={childId} id={childId} /&gt;
                ))}
            &lt;/View&gt;
        );
    }
    
    if (componentData.type === 'Text') {
        return &lt;Text&gt;{componentData.text}&lt;/Text&gt;;
    }
};

// 使用 memo 锁住渲染边界
const MemoizedGenUIRenderer = React.memo(GenUIRenderer);</code></pre>

    <h3>Step 3: 流式处理逻辑 (Stream Handler)</h3>
    <p>当网络收到一个片段 <code>{"id": "msg3", "type": "Text", "parent": "root"}</code> 时：</p>
    <ol>
        <li>在 Store 中写入 <code>msg3: { ... }</code>。 -> <strong>此时没有任何 UI 变化。</strong></li>
        <li>找到 `root` 对象，更新其 <code>childIds: ["msg1", "msg2", "msg3"]</code>。 -> <strong>触发信号。</strong></li>
        <li><strong>只有</strong> <code>GenUIRenderer(id="root")</code> 这个组件检测到数据变了，触发重绘。</li>
        <li>Root 组件重回，生成 3 个子组件。
            <ul>
                <li><code><Renderer id="msg1"/></code> -> Props 没变 -> <strong>跳过渲染</strong>。</li>
                <li><code><Renderer id="msg2"/></code> -> Props 没变 -> <strong>跳过渲染</strong>。</li>
                <li><code><Renderer id="msg3"/></code> -> 新组件 -> <strong>执行渲染</strong>。</li>
            </ul>
        </li>
    </ol>
    <p><strong>结果：</strong> 界面上瞬间“长”出了 msg3，性能开销极小 (O(1))。</p>

    <script>
        mermaid.initialize({ startOnLoad: true });
    </script>
</body>
</html>
